use std::path::PathBuf;
use std::sync::mpsc;

use vello::Scene;

use crate::layout::{self, Layout, LayoutConfig, LayoutRect};
use crate::render::cushion::CushionConfig;
use crate::render::scene::build_scene;
use crate::render::RenderState;
use crate::scanner;
use crate::scanner::types::ScanProgress;
use crate::tree::arena::{FileTree, NodeId};
use crate::ui::input::MouseState;
use crate::ui::navigation::NavigationState;
use crate::ui::overlay::Analytics;

/// Application state machine phases.
#[derive(Debug, PartialEq, Eq)]
pub enum AppPhase {
    /// Waiting for user to select a path to scan
    WaitingForPath,
    /// Scanning the filesystem
    Scanning,
    /// Ready to render the treemap
    Ready,
}

/// Top-level application state.
pub struct App {
    pub phase: AppPhase,
    pub scan_path: PathBuf,

    // Scan state
    pub scan_progress: Option<ScanProgress>,
    scan_rx: Option<mpsc::Receiver<ScanProgress>>,

    // Data
    pub tree: Option<FileTree>,
    pub layout: Option<Layout>,
    pub layout_config: LayoutConfig,
    pub cushion_config: CushionConfig,

    // UI state
    pub navigation: Option<NavigationState>,
    pub mouse: MouseState,
    pub hover_node: Option<NodeId>,
    pub analytics: Analytics,
    pub show_analytics_panel: bool,

    // Rendering
    pub scene: Scene,
    pub needs_relayout: bool,
    pub viewport_width: f32,
    pub viewport_height: f32,
}

impl App {
    pub fn new(scan_path: PathBuf) -> Self {
        Self {
            phase: AppPhase::WaitingForPath,
            scan_path,
            scan_progress: None,
            scan_rx: None,
            tree: None,
            layout: None,
            layout_config: LayoutConfig::default(),
            cushion_config: CushionConfig::default(),
            navigation: None,
            mouse: MouseState::default(),
            hover_node: None,
            analytics: Analytics::default(),
            show_analytics_panel: true,
            scene: Scene::new(),
            needs_relayout: true,
            viewport_width: 800.0,
            viewport_height: 600.0,
        }
    }

    /// Start scanning the filesystem in a background thread.
    pub fn start_scan(&mut self) {
        self.phase = AppPhase::Scanning;
        let (tx, rx) = mpsc::channel();
        self.scan_rx = Some(rx);

        let path = self.scan_path.clone();
        std::thread::spawn(move || {
            let progress_tx = tx.clone();
            match scanner::scan(&path, scanner::ScanMethod::Auto, progress_tx) {
                Ok(entries) => {
                    let tree = crate::tree::build_tree(&entries);
                    tracing::info!("Tree built: {} nodes", tree.len());
                    // Send a final completion signal with the tree
                    // (We'll send the tree via a separate channel in a real impl;
                    //  for now we serialize through progress)
                    let _ = tx.send(ScanProgress::Completed {
                        total_files: tree.len() as u64,
                        total_dirs: 0,
                        total_bytes: tree.get(tree.root).size,
                        elapsed_ms: 0,
                    });

                    // Store tree â€” in production we'd use a shared Arc<Mutex<>>
                    // For now, we'll use a different approach in the actual event loop
                    SCAN_RESULT.lock().unwrap().replace(tree);
                }
                Err(e) => {
                    tracing::error!("Scan failed: {}", e);
                    let _ = tx.send(ScanProgress::Error {
                        path,
                        message: e.to_string(),
                    });
                }
            }
        });
    }

    /// Poll for scan completion. Call this from the event loop.
    pub fn poll_scan(&mut self) -> bool {
        if let Some(rx) = &self.scan_rx {
            // Drain all available messages
            while let Ok(progress) = rx.try_recv() {
                match &progress {
                    ScanProgress::Completed { .. } => {
                        // Check if the tree is ready
                        if let Some(tree) = SCAN_RESULT.lock().unwrap().take() {
                            let root = tree.root;
                            self.tree = Some(tree);
                            self.navigation = Some(NavigationState::new(root));
                            self.phase = AppPhase::Ready;
                            self.needs_relayout = true;
                            self.scan_rx = None;
                            return true;
                        }
                    }
                    _ => {}
                }
                self.scan_progress = Some(progress);
            }
        }
        false
    }

    /// Recompute the treemap layout.
    pub fn relayout(&mut self) {
        if let (Some(tree), Some(nav)) = (&self.tree, &self.navigation) {
            tracing::info!(
                "Computing layout for tree with {} nodes, root={:?}, viewport={}x{}",
                tree.len(),
                nav.current_root,
                self.viewport_width,
                self.viewport_height
            );

            let computed_layout = layout::compute_layout(
                tree,
                nav.current_root,
                self.viewport_width,
                self.viewport_height,
                &self.layout_config,
            );

            tracing::info!("Layout computed: {} rectangles generated", computed_layout.rects.len());

            self.layout = Some(computed_layout);

            // Recompute analytics for the current view
            self.analytics = crate::ui::overlay::compute_analytics(tree, nav.current_root);

            self.needs_relayout = false;
        }
    }

    /// Rebuild the Vello scene from the current layout.
    pub fn rebuild_scene(&mut self) {
        if let (Some(tree), Some(layout)) = (&self.tree, &self.layout) {
            build_scene(
                &mut self.scene,
                tree,
                &layout.rects,
                &self.cushion_config,
                self.hover_node,
            );

            // Add UI overlays
            if self.show_analytics_panel {
                crate::ui::overlay::render_analytics_panel(
                    &mut self.scene,
                    &self.analytics,
                    self.viewport_width,
                    self.viewport_height,
                );
            }

            // Render tooltip if hovering
            if let Some(node_id) = self.hover_node {
                crate::ui::overlay::render_tooltip(
                    &mut self.scene,
                    tree,
                    node_id,
                    self.mouse.x,
                    self.mouse.y,
                );
            }

            // Breadcrumb at top
            if let Some(nav) = &self.navigation {
                crate::ui::overlay::render_breadcrumb(
                    &mut self.scene,
                    tree,
                    nav.current_root,
                    self.viewport_width,
                );
            }
        }
    }

    /// Handle viewport resize.
    pub fn resize(&mut self, width: u32, height: u32) {
        self.viewport_width = width as f32;
        self.viewport_height = height as f32;
        self.needs_relayout = true;
    }

    /// Handle drill-down navigation.
    pub fn drill_down(&mut self, node: NodeId) {
        if let (Some(tree), Some(nav)) = (&self.tree, &mut self.navigation) {
            if nav.drill_down(node, tree) {
                self.needs_relayout = true;
            }
        }
    }

    /// Handle navigate-up.
    pub fn navigate_up(&mut self) {
        if let Some(nav) = &mut self.navigation {
            if nav.navigate_up() {
                self.needs_relayout = true;
            }
        }
    }
}

// Temporary: global scan result for cross-thread communication.
// Will be replaced with proper channel-based approach.
use std::sync::Mutex;
static SCAN_RESULT: std::sync::LazyLock<Mutex<Option<FileTree>>> =
    std::sync::LazyLock::new(|| Mutex::new(None));
